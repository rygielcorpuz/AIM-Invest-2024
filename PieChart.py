# -*- coding: utf-8 -*-
"""OudomTrust.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-jjf0O2oLNTQD4qChM9guzpqMVS_iHdV
"""

Commented out IPython magic to ensure Python compatibility.
%%writefile Allocations.py
import numpy as np
import pandas as pd
import yfinance as yf
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
import numpy as np
from keras.layers import Dense, LSTM
from keras.models import Sequential
import json
def getAllocations():
    tickers = pd.read_html('https://en.wikipedia.org/wiki/List_of_S%26P_500_companies')[0][['Symbol', 'GICS Sector']]

    type(tickers['Symbol'])
    tickers['Symbol'] = tickers['Symbol'].str.replace('.', '-')
    tickers[tickers['Symbol'] == 'BF-B']

    sector_breakdown = tickers.groupby('GICS Sector')['Symbol'].apply(list)
    sector_breakdown = sector_breakdown.to_dict()

    ticker_list = []
    for sector in sector_breakdown:
        ticker_list.extend(sector_breakdown[sector])

    today = pd.Timestamp.today().strftime('%Y-%m-%d')
    month_ago = pd.Timestamp.today() - pd.DateOffset(months=60)

    data = yf.download(ticker_list, start=month_ago, end=today)
    data = data.drop(columns=['Open', 'High', 'Low', 'Close', 'Volume'])

    #update with bfill and ffill method instead
    data = data.fillna(method='bfill', axis=0)
    data = data.fillna(method='ffill', axis=0)

    returns = data.pct_change()
    returns = returns.droplevel(0, axis=1)

    raw_data = {}

    for sector, tickers in sector_breakdown.items():
        sector_data = returns[tickers]
        raw_data[sector] = sector_data.mean(axis=1)

    raw_data = pd.DataFrame(raw_data)

    raw_data = raw_data.dropna()
    raw_data
    results = pd.DataFrame(columns=raw_data.columns)

    for i, column in enumerate(raw_data.columns):
        y = raw_data[column]
        X = raw_data.drop(column, axis=1)

        scaler_x = MinMaxScaler()
        scaler_y = MinMaxScaler()

        X_scaled = scaler_x.fit_transform(X)
        y_scaled = scaler_y.fit_transform(y.values.reshape(-1, 1))

        X_scaled = X_scaled.reshape(X_scaled.shape[0], X_scaled.shape[1], 1)

        X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_scaled, test_size=0.33, random_state=42)

        model = Sequential()
        model.add(LSTM(units=5, return_sequences=True, input_shape=(X_train.shape[1], 1)))
        model.add(LSTM(units=5, return_sequences=False))
        model.add(Dense(units=25))
        model.add(Dense(units=1))

        model.compile(optimizer='adam', loss='mean_squared_error', metrics=['accuracy'])

        set_epoch = 20
        train = model.fit(X_train, y_train, batch_size=16, epochs=set_epoch, validation_split=0.1, verbose=0)
        raw_predictions = model.predict(X_test)
        pred = scaler_y.inverse_transform(raw_predictions)

        results[column] = pred.flatten()

    print(results)
    # Average the last 30 rows for each sector
    average_results = results.tail(30).mean()

    # Replace negative values with 0
    average_results[average_results < 0] = 0

    # Sum of the averaged results
    sum_results = average_results.sum()

    # Calculate the percentage of the sum for each sector
    allocations = (average_results / sum_results)

    # Display the percentage results
    print(allocations)

    # Convert allocations to a NumPy array
    allocations_array = np.array(allocations)

    p = [
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
    ]

    q = allocations_array

    print(p)
    print(q)
    print('Done')

    return q
getAllocations()

Commented out IPython magic to ensure Python compatibility.
%%writefile BLP.py
import math
import pandas as pd
import numpy as np
from scipy import optimize


# Prior portfolio for a model:
# ..assetClasses = tuple of strings
# ..weights = list of doubles, same length as assetClasses
# ..riskAversion = double
# ..covMatrix = covariance matrix of expected excess returns for assetClasses


class Portfolio:
    def __init__(self,
        assetClasses=('Communication Services','Consumer Discretionary','Consumer Staples','Energy','Financials','Health Care','Industrials','Information Technology','Materials','Real Estate','Utilities'),
        assetWeights=[0.09,0.1,0.09,0.09,0.09,0.09,0.09,0.09,0.09,0.09,0.09],
        riskAversion=2.5,
        covMatrix=None
    ):
        self.assetClasses = assetClasses
        self.weights = np.asarray(assetWeights)
        self.riskAversion = riskAversion
        self.covMatrix = covMatrix
        if covMatrix is None:
            self.covMatrix = pd.DataFrame(
                dict(zip(self.assetClasses, [[0,0]]*len(self.assetClasses)))
            ).cov()
        self.returns = self.computeReturns()

    def computeReturns(self):
        # Converting from 1D array to 2D column vector
        return (
            np.atleast_2d(
                self.riskAversion * np.dot(self.covMatrix, self.weights)
            ).T
        )


# Parameters for a model:
# ..priorPortfolio = Portfolio object
# ..tau = double
# ..tauv = double
# ..P = numpy matrix kXn, where k = # of views, n = # of asset classes
# ..Q = numpy matrix kX1, where k = # of views
class Parameters:
    def __init__(self, priorPortfolio, tau, tauv, P, Q):
        self.prior = priorPortfolio
        self.Pi = priorPortfolio.returns
        self.Sigma = priorPortfolio.covMatrix.values #pd DataFrame -> np array
        self.tau = tau
        self.tauv = tauv
        self.P = P
        self.Q = Q
        self.Omega = self.computeOmega()
        self.PiHat = self.computePostReturns()
        self.SigmaP = self.computePostVariance()

    def computeOmega(self):
        #Omega = tauv*P*Sigma*P_T, with nondiagonal entries set to 0
        return np.diag(np.diag(
            self.tauv*(np.dot(np.dot(self.P, self.Sigma), self.P.T))
        ))

    def computePostReturns(self):
        #PiHat = Pi + (tau*Sigma*P_T) * [(tau*P*Sigma*P_T)+Omega]^(-1) * [Q - P*Pi]
        #      = Pi + a * b^(-1) * c
        a = self.tau*np.dot(self.Sigma, self.P.T)
        b = self.tau*np.dot(np.dot(self.P, self.Sigma), self.P.T) + self.Omega
        c = self.Q - np.dot(self.P, self.Pi)
        return self.Pi + np.dot(np.dot(a, np.linalg.inv(b)), c)

    def computePostVariance(self):
        #SigmaP = Sigma + (tau*Sigma)
        #         - (tau*Sigma*P.T) * [P*tau*Sigma*P.T + Omega]^(-1) * P*tau*Sigma
        #       = u - a * b^(-1) * c
        u = self.Sigma + self.tau*self.Sigma
        a = self.tau*np.dot(self.Sigma, self.P.T)
        b = self.tau*np.dot(np.dot(self.P, self.Sigma), self.P.T) + self.Omega
        c = self.tau*np.dot(self.P, self.Sigma)
        return u - np.dot(np.dot(a, np.linalg.inv(b)), c)

    def postDistribution(self):
        return (np.ndarray.flatten(self.PiHat), self.SigmaP)


# Find weights which maximize Sharpe ratio
#..parameters = Parameters object
class Optimizer:
    def __init__(self, parameters):
        self.parameters = parameters
        self.result = self.optimizeWeights()
        self.success = self.result.success
        if self.result.success:
            self.optimalWeights = self.result.x
            self.optimalReturn = self.expectedReturn(self.optimalWeights)
            self.optimalSd = self.sd(self.optimalWeights)
            self.optimalSharpe = self.sharpe(self.optimalWeights)
        else:
            print('In Optimizer: there was a problem finding the optimal weights')
            print('Return message from optimize.minimize:')
            print(self.result.message)

    def expectedReturn(self, weights):
        return np.dot(np.atleast_2d(weights), self.parameters.PiHat).item()

    def sd(self, weights):
        w = np.atleast_2d(weights)
        weightedCov = np.dot(np.dot(w, self.parameters.SigmaP), w.T)
        return math.sqrt(np.sum(weightedCov))

    def sharpe(self, weights):
        return self.expectedReturn(weights)/self.sd(weights)

    def optimizeWeights(self):
        optResult = optimize.minimize(
            fun=lambda x: -1*self.sharpe(np.atleast_2d(x)),
            x0=np.ndarray.flatten(self.parameters.prior.weights),
            method='SLSQP',
            constraints={
                'fun': lambda x: 1 - np.sum(x),
                'type': 'eq'
            }
        )
        return optResult

    def optimalData(self):
        if self.success:
            return (
                list(self.optimalWeights),
                self.optimalReturn,
                self.optimalSd,
                self.optimalSharpe
            )


# Create an optimal portfolio using the Black-Litterman model
# ..prior = a Portfolio object representing the prior return distribution
# ......Or pass assetClasses, weights, riskAversion, and covMatrix
# ......to the class method Model.fromPriorData. See Portfolio definition
# ......above
# ..tau = a scalar constant
# ..tauv = a scalar constant
# ..P = numpy matrix kXn, where k = # of views, n = # of asset classes
# ..Q = numpy matrix kX1, where k = # of views
# ..identifier = number or string to identify the model, default -1
class Model:
    def __init__(self, prior, tau, tauv, P, Q, identifier=-1):
        self.identifier = identifier
        self.prior = prior
        self.assetClasses = prior.assetClasses
        self.tau = tau
        self.tauv = tauv
        self.P = P
        self.Q = Q
        self.parameters = Parameters(prior, tau, tauv, P, Q)
        self.optimizer = Optimizer(self.parameters)
        if self.optimizer.success:
            self.weights, self.returns, self.sd, self.sharpe = self.optimizer.optimalData()
            self.optimalPortfolio = dict(zip(
                ('weights', 'returns', 'sd', 'sharpe'),
                self.optimizer.optimalData()
            ))
            self.framer = ModelFramer(self, self.identifier)
            self.df = self.framer.df
        else:
            print('In Model: there was a problem finding the optimal weights')
            print('Return message from optimize.minimize:')
            print(self.optimizer.result.message)

    @classmethod
    def fromPriorData(cls,
        assetClasses, assetWeights, riskAversion, covMatrix,
        tau, tauv, P, Q,
        identifier=-1
    ):
        prior = Portfolio(assetClasses, assetWeights, riskAversion, covMatrix)
        return cls(prior, tau, tauv, P, Q, identifier)

    def didGeneratePortfolio(self):
        return self.optimizer.success

    def posteriorDistribution(self):
        return self.parameters.postDistribution()

    def listPriorReturns(self):
        return list(np.ndarray.flatten(self.prior.returns))

    def listPriorWeights(self):
        return list(self.prior.weights)


# Build a pandas DataFrame out of a Model, for printing to csv
# ..model = Model object
# ..identifier = number or string to identify the model (default -1)
class ModelFramer:
    def __init__(self, model, identifier=-1):
        self.model = model
        self.identifier = identifier
        self.prior = self.makePrior()
        self.head = self.makeHead()
        self.views = self.makeViews()
        self.dist = self.makeDist()
        self.optimal = self.makeOptimal()
        self.df = pd.concat((self.head, self.views, self.dist, self.optimal))

    # Note: expects a numpy array for covMatrixValues
    def covDf(self, covMatrixValues, label):
        df = pd.concat((
                pd.DataFrame.from_dict({
                    label: self.model.assetClasses
                }, orient='index'),
                pd.DataFrame(covMatrixValues)
            ))
        df.index = [label] + self.model.assetClasses
        return df

    def makePrior(self):
        return pd.concat((
            pd.DataFrame.from_dict({
                'Asset classes': self.model.assetClasses,
                'Prior weights': self.model.listPriorWeights(),
                'Risk aversion': [self.model.prior.riskAversion],
                'Prior returns': self.model.listPriorReturns()
            }, orient='index'),
            self.covDf(self.model.prior.covMatrix.values, 'Prior covariance matrix')
        ))

    def makeHead(self):
        return pd.DataFrame.from_dict({
            'Model Identifier': [self.identifier],
            'Prior weights': list(self.model.prior.weights),
            'Parameters': [
                'Risk aversion', self.model.prior.riskAversion,
                'Tau', self.model.parameters.tau,
                'Tauv', self.model.parameters.tauv
                ],
            }, orient='index')

    def makeViews(self):
        assetClasses = self.model.assetClasses
        dfP = pd.concat((
            pd.DataFrame.from_dict({'P': assetClasses}, orient='index'),
            pd.DataFrame(self.model.parameters.P)
        ))
        dfQ = pd.concat((
            pd.DataFrame.from_dict({'Q': []}, orient='index'),
            pd.DataFrame(self.model.parameters.Q)
        ))
        df = pd.concat((dfP, dfQ))
        df.index = (
            ['P'] + ['View ' + str(ind) for ind in dfP.index[1:]] +
            ['Q'] + ['View ' + str(ind) for ind in dfQ.index[1:]]
        )
        return df

    def makeDist(self):
        postReturns, postVars = self.model.posteriorDistribution()
        return pd.concat((
            pd.DataFrame.from_dict({
                'Posterior expected returns': postReturns
                }, orient='index'),
            self.covDf(postVars, 'Posterior covariance matrix')
        ))

    def makeOptimal(self):
        op = self.model.optimalPortfolio
        return pd.DataFrame.from_dict({
            'Optimal weights': op['weights'],
            'Optimal portfolio metrics': [
                'Expected return', op['returns'],
                'Sd', op['sd'],
                'Sharpe', op['sharpe']
                ]
        }, orient='index')


from collections import OrderedDict
import pandas as pd
import numpy as np
from BLP import Model
from Allocations import getAllocations
import json

def Allocator(r):
    def writeResults(filename, models):
        writeDf = pd.concat([models[0].framer.prior] + [m.df for m in models])
        writeDf.to_csv(filename, header=False)

    assetInfo = {'Communication Services':.1,'Consumer Discretionary':.09,'Consumer Staples':.09,'Energy':.09,'Financials':.09,'Health Care':.09,'Industrials':.09,'Information Technology':.09,'Materials':.09,'Real Estate':.09,'Utilities':.09}
    assetClasses = list(assetInfo.keys())
    assetWeights = list(assetInfo.values())

    data = pd.read_csv(r'10yBackData.csv', usecols=assetClasses)
    data = data[:100]
    covMatrix = data.cov()

    

    print('Computing models...')

    allocations = getAllocations()

    P_value=np.asarray([[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]])
    Q_value=np.asarray([[allocations[0]],[allocations[1]], [allocations[2]], [allocations[3]], [allocations[4]], [allocations[5]], [allocations[6]],
    [allocations[7]],         [allocations[8]],  [allocations[9]],         [allocations[10]]        ])


    # for i in range(1):
        #len(data.columns)
    model = Model.fromPriorData(
        assetClasses,
        assetWeights,
        riskAversion=r,
        covMatrix=covMatrix,
        tau=0.1,
        tauv=0.1,
        P=P_value,
        Q=Q_value,
        identifier=1
    )

    # print(model.optimalPortfolio['weights'])
    optimalWeights = model.optimalPortfolio['weights']
    assetWeightsDict = {asset: weight for asset, weight in zip(assetClasses, optimalWeights)}
    sharpe = model.optimalPortfolio['sharpe']


    weights_dict = {}

    for asset, weight in assetWeightsDict.items():
        print(f'{ asset }: { weight }')
        weights_dict[asset] = weight


    # Convert the dictionary to a JSON-formatted string
    json_weights = json.dumps(weights_dict)

    print(f'portfolio Sharpe ratio: { sharpe }')



    model_two = Model.fromPriorData(
        assetClasses,
        assetWeights,
        riskAversion=r,
        covMatrix=covMatrix,
        tau=0.1,
        tauv=0.01,
        P=np.asarray([[1,0,1,0,1,0,1,0,1,0,1]]),
        Q=np.asarray([[0.015]]),
        identifier=2
    )

    model_three = Model.fromPriorData(
        assetClasses,
        assetWeights,
        riskAversion=r,
        covMatrix=covMatrix,
        tau=0.1,
        tauv=0.01,
        P=np.asarray([[0,0,0,0,0,0,0,0,1,0,0]]),
        Q=np.asarray([[0.015]]),
        identifier=3
    )
    # print(model_one)
    models = (model_three, model_two)
    outFile = 'new_example_output.csv'
    writeResults(outFile, models)

    print('Done.')
    print(f'Check the model results in { outFile }')

    return json_weights

#print(Allocator(7)) For testing purposes

# GET RISK AVERSION SCORE FROM USER
# OUDOM EDIT HERE
risk_score = 13.5
portfolio_weights = Allocator(risk_score)

import plotly.express as px
# THIS IS HARD CODED DATA USE DATA FROM 2 MODELS
# OUDOM EDIT HERE
# Define your asset classes and their corresponding allocations
asset_classes = [
    'Communication Services', 'Consumer Discretionary', 'Consumer Staples',
    'Energy', 'Financials', 'Health Care', 'Industrials', 'Information Technology',
    'Materials', 'Real Estate', 'Utilities'
]

allocations = [
    -0.47312298643488293, 0.053050744198994394, -0.6107992816519578,
    0.49255242795907644, 0.14420839055863732, 0.17455517102087623,
    0.04867145837128394, 0.2785425979972478, -0.09150048677916986,
    0.9188028169402195, 0.06503914781967507
]

# Filter out negative allocations and their corresponding asset classes
positive_allocations = []
positive_asset_classes = []
negative_asset_classes = []

for asset, alloc in zip(asset_classes, allocations):
    if alloc >= 0:
        positive_asset_classes.append(asset)
        positive_allocations.append(alloc)

import pandas as pd
df = pd.DataFrame({'Asset Class': positive_asset_classes, 'Allocation': positive_allocations})

# Plotting the pie chart for positive allocations
fig = px.pie(df, values='Allocation', names='Asset Class', title='Portfolio Allocations (Positive Allocations Only)')
fig.update_traces(textposition='inside', textinfo='percent+label')

# Display the plot
fig.show()

